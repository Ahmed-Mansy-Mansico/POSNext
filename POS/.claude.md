# Claude Code Rules for POS Next

This file contains project-specific rules and conventions for Claude Code when working on the POS Next application.

## API Call Patterns

### Rule: Use Different API Patterns Based on File Type

**Vue Components (.vue files)** → **MUST use `createResource` from frappe-ui**

```javascript
// ✅ CORRECT - Vue Component
import { createResource } from 'frappe-ui'

const myResource = createResource({
	url: 'frappe.client.get_list',
	makeParams() {
		return {
			doctype: 'Customer',
			fields: ['name', 'customer_name']
		}
	},
	auto: false,
	onSuccess(data) {
		// Handle success
	},
	onError(error) {
		// Handle error
	}
})

// Use in template
<Button @click="myResource.reload()" :loading="myResource.loading">
```

**JavaScript Utilities (.js files)** → **MUST use `window.frappe.call`**

```javascript
// ✅ CORRECT - JavaScript Utility
export async function fetchData() {
	try {
		const response = await window.frappe.call({
			method: 'frappe.client.get_list',
			args: {
				doctype: 'Customer',
				fields: ['name', 'customer_name']
			}
		})
		return response.message
	} catch (error) {
		console.error('Error:', error)
		throw error
	}
}
```

**Rationale:**
- **Vue components** benefit from `createResource`'s reactive loading states, error handling, and lifecycle integration
- **JavaScript utilities** are standalone functions that can directly use Frappe's global API without Vue dependencies

### ❌ INCORRECT Examples

```javascript
// ❌ WRONG - Don't use window.frappe.call in Vue components
<script setup>
async function loadData() {
	const response = await window.frappe.call({...}) // BAD!
}
</script>

// ❌ WRONG - Don't use createResource in JS utilities
import { createResource } from 'frappe-ui' // BAD in .js files!
export const myResource = createResource({...})
```

## Error Handling

### Toast Notifications in Vue Components

Use `toast.create` from frappe-ui for user-facing notifications:

```javascript
import { toast } from 'frappe-ui'

toast.create({
	title: 'Success',
	text: 'Operation completed successfully',
	icon: 'check',
	iconClasses: 'text-green-600',
})

toast.create({
	title: 'Error',
	text: error.message || 'Operation failed',
	icon: 'alert-circle',
	iconClasses: 'text-red-600',
})
```

### Never use `window.frappe.msgprint` in Vue components

```javascript
// ❌ WRONG
window.frappe.msgprint({
	title: 'Error',
	message: 'Something went wrong'
})

// ✅ CORRECT
toast.create({
	title: 'Error',
	text: 'Something went wrong',
	icon: 'alert-circle',
	iconClasses: 'text-red-600',
})
```

## Offline Support

### IndexedDB Boolean Queries

When querying boolean fields in IndexedDB/Dexie, always use `.filter()` instead of `.where().equals()`:

```javascript
// ❌ WRONG - Causes DexieError with boolean values
const items = await db.invoice_queue
	.where('synced').equals(false)
	.toArray()

// ✅ CORRECT - Use filter for boolean values
const items = await db.invoice_queue
	.filter(invoice => invoice.synced === false)
	.toArray()
```

## Component Patterns

### Dialog Accessibility

Always provide screen-reader descriptions for dialogs:

```vue
<template>
	<Dialog v-model="show" :options="{ title: 'Dialog Title', size: 'md' }">
		<template #body-title>
			<span class="sr-only">Description for screen readers</span>
		</template>
		<template #body-content>
			<!-- Dialog content -->
		</template>
	</Dialog>
</template>

<style scoped>
.sr-only {
	position: absolute;
	width: 1px;
	height: 1px;
	padding: 0;
	margin: -1px;
	overflow: hidden;
	clip: rect(0, 0, 0, 0);
	white-space: nowrap;
	border-width: 0;
}
</style>
```

## File Organization

### Component Structure

```
POS/src/
├── components/
│   ├── sale/              # POS sale-related components
│   ├── shift/             # Shift management components
│   └── common/            # Shared components
├── composables/           # Vue composables (useOffline, useInvoice, etc.)
├── pages/                 # Main pages (POSSale, Login, Home)
├── utils/                 # Utility functions (.js files)
│   └── offline/          # Offline-specific utilities
└── router.js             # Vue Router configuration
```

## Code Style

### Prefer Editing Over Creating

- **ALWAYS** prefer editing existing files over creating new ones
- Only create new files when absolutely necessary
- Check for existing similar functionality before creating new components

### No Unnecessary Documentation

- Do NOT create documentation files (*.md) unless explicitly requested
- Do NOT create README files proactively
- Keep inline code comments concise and relevant

### Emoji Usage

- Only use emojis if explicitly requested by the user
- Avoid emojis in code, comments, and commit messages by default

## Database Field Names

### POS Payment Method

The `POS Payment Method` child table does NOT have a `default_account` field. To get the payment account:

```python
# ❌ WRONG
payment_method = frappe.db.get_value(
	"POS Payment Method",
	{"parent": pos_profile, "mode_of_payment": mode_of_payment},
	["default_account", "allow_in_returns"],  # default_account doesn't exist!
	as_dict=1
)

# ✅ CORRECT
# First check if payment method is in POS Profile
payment_method = frappe.db.get_value(
	"POS Payment Method",
	{"parent": pos_profile, "mode_of_payment": mode_of_payment},
	"allow_in_returns"
)

# Then get account from Mode of Payment Account table
mop_account = frappe.db.get_value(
	"Mode of Payment Account",
	{"parent": mode_of_payment, "company": company},
	"default_account"
)
```

### Customer Group Attribute

The standard ERPNext `POS Profile` doctype may not have a `customer_group` field. Always check before accessing:

```python
# ✅ CORRECT
pos_profile_doc = frappe.get_cached_doc("POS Profile", pos_profile)
if hasattr(pos_profile_doc, 'customer_group') and pos_profile_doc.customer_group:
	filters["customer_group"] = pos_profile_doc.customer_group
```

## Offline Implementation

### Critical Rule: Use Web Worker for All Offline Operations

**ALL offline operations MUST run in the Web Worker, not the main thread:**

```javascript
// ✅ CORRECT - Using worker for offline operations
import { offlineWorker } from '@/utils/offline/workerClient'

async function loadData() {
	const cacheReady = await offlineWorker.isCacheReady()
	if (isOffline() || cacheReady) {
		// Worker handles IndexedDB operations in background thread
		const data = await offlineWorker.searchCachedItems()
		return data
	} else {
		// Use server if online and cache not ready
		await serverResource.reload()
	}
}

// ❌ WRONG - Running IndexedDB on main thread
import { searchCachedItems } from '@/utils/offline'
const data = await searchCachedItems() // Blocks UI!
```

**Worker Architecture:**
- `/src/workers/offline.worker.js` - Web Worker handles all IndexedDB operations
- `/src/utils/offline/workerClient.js` - Promise-based API for main thread
- All database, sync, and cache operations run in background thread
- Main thread only handles UI and Frappe API calls

### Critical Rule: Cache-First Data Loading

**Always load from cache first, server second:**

```javascript
// ✅ CORRECT - Cache-first approach using worker
async function loadData() {
	const cacheReady = await offlineWorker.isCacheReady()
	if (isOffline() || cacheReady) {
		// Use cache when offline or cache is available
		const data = await offlineWorker.searchCachedItems()
		return data
	} else {
		// Only use server if online and cache not ready
		await serverResource.reload()
	}
}

// ❌ WRONG - Always trying server first
const resource = createResource({
	url: 'api.get_items',
	auto: true  // This fails when offline!
})
```

### Data Pre-Loading Pattern

**POS must pre-load data when online (still uses main thread for API calls):**

```javascript
import { cacheItemsFromServer, cacheCustomersFromServer } from '@/utils/offline'

onMounted(async () => {
	const cacheReady = await offlineWorker.isCacheReady()
	if (!isOffline() && !cacheReady) {
		// Fetch from server (main thread - uses window.frappe.call)
		const items = await fetchItemsFromServer(posProfile)
		const customers = await fetchCustomersFromServer(posProfile)

		// Cache via worker (background thread)
		await offlineWorker.cacheItems(items)
		await offlineWorker.cacheCustomers(customers)

		// Show success notification
		toast.create({
			title: "Sync Complete",
			text: "Data is ready for offline use"
		})
	}
})
```

### Cache Management Functions (via Worker)

**Available worker methods - ALL run in background thread:**
- `offlineWorker.isCacheReady()` - Check if cache has data
- `offlineWorker.getCacheStats()` - Get cache statistics
- `offlineWorker.searchCachedItems(term, limit)` - Search items in cache
- `offlineWorker.searchCachedCustomers(term, limit)` - Search customers in cache
- `offlineWorker.cacheItems(items)` - Cache items array
- `offlineWorker.cacheCustomers(customers)` - Cache customers array
- `offlineWorker.saveOfflineInvoice(data)` - Save invoice to queue
- `offlineWorker.getOfflineInvoices()` - Get queued invoices
- `offlineWorker.getOfflineInvoiceCount()` - Get queue count
- `offlineWorker.deleteOfflineInvoice(id)` - Delete from queue
- `offlineWorker.checkOffline(browserOnline)` - Check offline status
- `offlineWorker.pingServer()` - Ping server for connectivity
- `offlineWorker.setManualOffline(value)` - Set manual offline mode

### Offline-Aware Composables

**useItems pattern (uses worker):**
```javascript
import { useItems } from '@/composables/useItems'

// In component
const { items, loading, loadItems, checkCacheReady, isOffline } = useItems(posProfile)

// Load items (automatically uses worker for cache operations)
await loadItems()

// Check cache status via worker
const ready = await checkCacheReady()
```

**useOffline pattern (uses worker):**
```javascript
import { useOffline } from '@/composables/useOffline'

const {
	isOffline,
	pendingInvoicesCount,
	saveInvoiceOffline,
	syncPending,
	getCacheStats
} = useOffline()

// All database operations run in worker
await saveInvoiceOffline(invoiceData)
const stats = await getCacheStats()
```

**Cache checking in components:**
```javascript
import { offlineWorker } from '@/utils/offline/workerClient'

// Check via worker (non-blocking)
const cacheReady = await offlineWorker.isCacheReady()
if (isOffline() && !cacheReady) {
	toast.create({
		title: "Limited Functionality",
		text: "POS is offline without cached data"
	})
}
```

## Common Issues & Solutions

### Issue: "Unknown column 'default_account' in 'SELECT'"
**Solution:** Use `Mode of Payment Account` table, not `POS Payment Method`

### Issue: "ValidationError: 'POSProfile' object has no attribute 'customer_group'"
**Solution:** Always use `hasattr()` check before accessing optional fields

### Issue: "DexieError: The parameter is not a valid key"
**Solution:** Use `.filter()` instead of `.where().equals()` for boolean values

### Issue: "Frappe API not available" errors
**Solution:** In Vue components, use `createResource` which handles API availability automatically

### Issue: "POS doesn't work offline"
**Solution:** Ensure data is pre-loaded when online using `cacheItemsFromServer()` and `cacheCustomersFromServer()`

### Issue: "Empty items/customers list"
**Solution:** Use cache-first loading pattern - check `isOffline()` or `isCacheReady()` before loading data

---

*Last Updated: 2025-10-01*
*Project: POS Next - Modern POS System for ERPNext*
*Offline-First Architecture: ✅ Implemented*
